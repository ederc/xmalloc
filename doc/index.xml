<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
               "docbook/dtd/xml/4.2/docbookx.dtd">
<article>
  <articleinfo>
    <title>Getting started with xmalloc</title>
    <copyright>
      <year>2012</year>
      <holder>Christian Eder</holder>
    </copyright>
  </articleinfo>
  <sect1>
    <title>Downloading and installing</title>

    <para>
      Developement of xmalloc occurs at
      its <ulink url="https://github.com/ederc/xmalloc">GIT
      repository</ulink> to which anyone may obtain read-only access.
    </para>
    <sect2>
    <title>Basic installation</title>
    <para>
      See the file INSTALL in the xmalloc-distribution for detailed
      installation-instructions. The basic procedure is
      <programlisting>
        ./autogen.sh
        ./configure
        make
        make install</programlisting>
    </para>
    </sect2>
    <sect2>
    <title>Optimizations during the build process</title>
    <para>
      Of course, an optimized memory management depends highly on compile-time
      predefined macros. Moreover, a good performance clearly depends on the
      operating system as well as the CPU. Thus it is inevitable that some of
      those macros cannot be determined during compile-time. Instead of moving
      away from fast macros and checking needed data via configuration scripts
      at the beginning of the application we stuck with macros and define
      sensitive default values. Of course any of these macros can be customized
      by the user during the build process by handing the configure script the
      corresponding data.
    </para>
    <sect3>
      <title>Cache line size</title>
      <para>
        The cache line size of a CPU is very important for efficient allocations.
        xmalloc tries to achieve a high cache locality without wasting too much
        space. For this xmalloc depends on two macros called
        <varname>__XMALLOC_SIZEOF_CACHELINE</varname> and
        <varname>__XMALLOC_LOG_SIZEOF_CACHELINE</varname>. The coresponding values
        are given in kB. For default the configure script of xmalloc sets them to
        <programlisting>
        __XMALLOC_SIZEOF_CACHELINE     = 64
        __XMALLOC_LOG_SIZEOF_CACHELINE =  6</programlisting>
      </para>
      <para>
        Those values are most common on current x86-64 CPUs. Of course, there exist other
        architecture with different settings. It is quite hard to find out those values
        cross-platform, even more in compile time. The user can customize those values by
        passing the corresponding environmental values to the configure script, e.g.
        <programlisting>
        ./configure CPPFLAGS="-D__XMALLOC_SIZEOF_CACHELINE=32 -D__XMALLOC_LOG_SIZEOF_CACHELINE=5"</programlisting>
        sets the cache line size to 32kB.
      </para>
      <note>
      <orderedlist>
      <listitem>
      <para>
        Whenever you change <varname>__XMALLOC_SIZEOF_CACHELINE</varname> you should also adjust
        <varname>__XMALLOC_LOG_SIZEOF_CACHELINE</varname> correspondingly. Otherwise efficient
        allocations cannot be garantied.
      </para>
      </listitem>
      <listitem>
      <para>
        There exists an internal checker for the cache line size in <filename>src/cache.h</filename>
        called <function>xCacheLineSize()</function>. This function is not used to determine the
        corresponding values for <varname>__XMALLOC_SIZEOF_CACHELINE</varname> respectively
        <varname>__XMALLOC_LOG_SIZEOF_CACHELINE</varname>. It is a leftover from an earlier step
        implementing xmalloc where the decision of how to handle these data was not made. We keep
        this implementation until xmalloc gets kind of stable as there are possible design
        changes in the future.
      </para>
      </listitem>
      </orderedlist>
      </note>
    </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>General ideas behind xmalloc</title>
    <para>
      xmalloc allocates memory on a page-based style, i.e. for each size class
      xmalloc always keeps a complete page as free list. The general idea is to
      allocate huge continuous blocks of memory rarely on a global level.
      Whenever a thread needs a new page for a given size class, this is taken
      from the global pool in order to make allocation faster. Moreover, we
      adopt the thread-caching idea from
      <ulink url="http://gperftools.googlecode.com/">tcmalloc</ulink> to
      keep operations as much lock-free as possible.
    </para>
    <para>
      xmalloc is a fork of <type>omalloc</type>, the memory allocator
      developed especially for the computer algebra system SINGULAR. The hope
      is to switch from omalloc to xmalloc in the near future since omalloc
      lacks support for multi-threaded computations. Moreover, one of the main
      tasks developing xmalloc is to introduce a good-balanced thread handling
      system without losing too much speed compared to omalloc.
    </para>
    <caution>
      <para>
        xmalloc is dedicated for fast, packed allocation and deallocation of
        memory blocks of size smaller than approximately 1024kB. It is not
        supposed to replace your system allocator.
      </para>
    </caution>
  </sect1>
  <sect1>
    <title>General structure of xmalloc</title>
    <para>
      xmalloc consists of a quite special structure due to the strong interlocking
      of its basic data structures.
    </para>
  <sect2>
    <title>Basic data structures in xmalloc</title>
    <para>
      xmalloc is mainly based on 3 data structures.
    </para>
  <sect3>
    <title>xRegions, pools of system pages</title>
    <para>
      <type>xRegion</type>s are the largest objects of continuous
      memory handled by xmalloc. At the very beginning and once in a while during
      the computations your programm needs new memory from the system. In order to
      keep the influence of this slow and locking process as small as possible
      xmalloc allocates a huge chunk of pages from the system at once and stores
      it as an <type>xRegion</type>. Those <type>xRegion</type>s
      represent pools of memory for xmalloc from which it can get memory quite
      fast.
    </para>
  </sect3>
  <sect3>
    <title>xBins, free lists of same sized memory chunks</title>
    <para>
      Since the emphasis of xmalloc lies in allocating and freeing lots of
      same-sized memory chunks smaller than 1024 kB fast we keep for a number
      of small size classes free lists. Those lists are called
      <type>xBin</type>s. Besides the lists of free memory chunks
      and its handling an <type>xBin</type> consists of meta data:
      <orderedlist>
        <listitem>
          <para>
            The size class of the objects stored in the free lists.
          </para>
        </listitem>
        <listitem>
          <para>
            The number of blocks available in each entry of memory chunk
            in the free lists.
          </para>
        </listitem>
      </orderedlist>
      Whereas the second meta data sounds strange at a first look the idea
      behind it is based on the fact that each such free list consists of
      complete system pages. Thus the number of blocks available can be
      calculated beforehand without any bigger overhead, making later checks of
      available free memory faster.
    </para>
  </sect3>
  <sect3>
    <title>xPages, system pages with special headers</title>
    <para>
      For handling the pages in xmalloc a so-called <type>xPage</type>
      is used. Since all such pages are stored in a given <type>xBin
      </type> it is not necessary to store meta data like the size
      class or the number of blocks. This allows a tighter packing of
      data and improves cache locality. Again, note, that each such <type>
      xPage</type> corresponds to an entry in a free list of an <type>
      xBin</type>.
    </para>
  </sect3>
  </sect2>
  <sect2>
    <title>Folder structure of xmalloc</title>
    <orderedlist>
    <listitem>
    <para>
      In the <filename>include/</filename> folder <filename>
      xmalloc-config.h</filename> is located. This header file consists
      of macros defined by <function>./configure</function>. Here system
      resp. architecture-dependent data is defined.
    </para>
    </listitem>
    <listitem>
    <para>
      The main files of xmalloc are located in <filename>src/</filename>.
      There one finds all functionality of xmalloc. The files <filename>
      page.*</filename>, <filename>bin.*</filename> and <filename>region.*
      </filename> implement all functions depending on the above mentioned
      3 data types. Note that due to the strong interlocking, especially
      between <type>xPage</type> and <type>xBin</type> some functions
      concerning <type>xPage</type>s are located in <filename>bin.*
      </filename> since they highly depend on <type>xBin</type>s, too.
    </para>
    <para>
      The above mentioned data types and corresponding relatives are
      defined in <filename>data.h</filename>. In <filename>globals.*
      </filename> most of the global variables that could not be pre-
      defined by <function>./configure</function> in <filename>
      include/xmalloc-config.h</filename> are located. General functionality
      for system calls and alignments are found in <filename>system.*</filename>
      resp. <filename>align.*</filename>
    </para>
    <para>
      Here is a simplified graph of the interconnections in the <filename>
      src/</filename> folder:
      <programlisting>
                            data.h
                              |
                              |
                system.h  globals.h  align.h
                        \     |     /
                         \    |    /
                           region.h
                            /    \
                           /      \
                        bin.h --- page.h
                           \      /
                            \    /
                           xmalloc.h</programlisting>
    </para>
    </listitem>
    <listitem>
    <para>
      The <filename>tests/</filename> folder consists of unit tests and bigger
      tests for xmalloc functionality. Those tests are performed and rated
      during a <function>make check</function>. For tests depending or
      generating huge amounts of data, the subfolder <filename>
      tests/data/</filename> is used.
    </para>
    </listitem>
    <listitem>
    <para>
      The complete documentation is found in the <filename>doc/</filename> folder.
      This includes not only this html-only overview of xmalloc, but also a
      complete <ulink url="http://www.stack.nl/~dimitri/doxygen/">Doxygen</ulink>-generated
      reference in html as well as in tex format.
    </para>
    </listitem>
    </orderedlist>
  </sect2>
  </sect1>
  <sect1>
    <title>An overview on how xmalloc allocates and frees memory in general</title>
    <para>
      In this section we try to give a general description of how allocates respectively
      frees memory step-by-step. This is by no means a comprehensive explanation of all
      subprocesses going on, but it should provide the reader with an overall feeling
      for the ideas behind xmalloc.
    </para>
  <note>
    <para>
      Memory of size > 1024 kB is handled by the operating system's memory manager. Of course
      at some point, e.g. when freeing the memory again, xmalloc needs to decide whether
      the memory was allocated by xmalloc itself or by the system-wide malloc. We do not
      consider these distinctions, but focus on memory chunks &le; 1024 kB. There xmalloc's
      main functionality lies in.
    </para>
  </note>
  <sect2>
    <title>Memory allocation</title>
    <para>
      As in ever memory allocator one has to distinguish between initial memory allocations
      which consists of lots of steps in order to structure and manage bigger blocks of memory
      and the general memory allocation which is done rather fast due to the administrative
      preparations in the beginning.
    </para>
    <para>
      We start with an description of the very first allocations of xmalloc. This we are doing
      in 3 different parts.
    </para>
  <sect3>
    <title>Allocating memory in the beginning</title>
    <para>
      In the following let us assume that an application using xmalloc for its memory
      management needs to allocate memory of size <varname>m</varname>.
    </para>
    <para>
      On the very first allocations of xmalloc there are no <type>xBin</type>s ready the
      chunk of memory to be stored can be saved in. There exist predefined arrays of initial
      <type>xBin</type>s called <varname>xStaticBin</varname>. Those have no initial pages, but are
      specialised such that xmalloc knows that there need some <type>xPage</type>s to be
      allocated for the corresponding size class memory of size <varname>m</varname> fits in.
    </para>
    <para>
      Free system pages are stored in the <type>xRegion</type>s. Of course, in the
      beginning the <type>xRegion</type>s do not have any such page allocated, thus on the first
      run xmalloc allocates a large chunk of memory consisting of a multiple of the systems
      page size to such an <type>xRegion</type>.
    </para>
    <para>
      Once this is done the <type>xBin</type> suitable for memory of size <varname>m</varname>
      can grab a system page from the <type>xRegion</type>, give it a header specialised for
      xmalloc.
    </para>
  </sect3>
  <sect3 id="initxpages">
    <title id="initxpages.title">Initializing new xPages</title>
    <para>
      It is important to understand how xmalloc initializes <type>xPage</type>s, not only for
      the allocation process itself, but also for the freeing of memory later on:
    </para>
    <para>
      Each memory of an <type>xPage</type> has a given block size due to the <type>xBin</type>
      it is allocated to. Each such block can be thought of as described in the following:
      <programlisting>
      tmp = page-&gt;current // special situation where tmp points at the current free entry in the xPage
                          // but one can think of tmp to point at any memory block in the xPage
               ----------------------------------          ----------------------------------
      tmp-----&gt;|  *  |  real data of the block  |   /-----&gt;|  *  |  real data of the block  |
               ---|------------------------------  /       ---|------------------------------
                  |                               /           |
               next element----------------------/         next element</programlisting>
      This initialization is done in function <function>xAllocNewPageForBin()</function> in
      file <filename>src/bin.c</filename>
    </para>
    <para>
      With this structure it is very easy to achieve the next element in the <type>xPage</type>:
      Let <varname>tmp</varname> be of type <type>void *</type> and point to any memory block of
      the <type>xPage</type> as presented in the picture above. If we want to get the address of
      the next memory block in this page we just need to dereference <varname>tmp</varname>:
      <programlisting>
      *(void **)tmp = next element in xPage</programlisting>
    </para>
    <para>
      In order to simplify using xmalloc there is an easier way of getting the next
      <type>xPage</type>, namely
      <programlisting>
      __XMALLOC_NEXT(tmp) </programlisting>
    </para>
    </sect3>
    <sect3>
    <title>Finally, getting the memory address</title>
    <para>
      Furthermore, the pointer to the current page to
      allocate from in this <type>xBin</type> is set to this newly allocated page ( more
      specific to the first free block behind the header of the <type>xPage</type> ).
    </para>
    <para>
      Next xmalloc can allocate memory of size <varname>m</varname> from this <type>xPage</type>
      and updates some page data like the number of used blocks, etc.
    </para>
    <para>
      This leads to a description of the general memory allocation procedure taking place.
    </para>
  </sect3>
  <sect3>
    <title>A usual memory allocation in xmalloc</title>
    <para>
      Clearly, the differnt allocations mentioned in the above section are costly
      computational steps and should be averted as much as possible. The nice fact is that in
      general xmalloc does not do all these steps when a new block of memory needs to be
      allocated.
    </para>
    <para>
      In general, the situation is the following: For any size class xmalloc supports the
      corresponding <type>xBin</type> has already allocated <type>xPage</type>s from the
      current <type>xRegion</type>. Those <type>xPages</type> might be partially free. Then all
      xmalloc has to do is to decide via a fast lookup in which size class the memory of size
      <varname>m</varname>fits in, gets the corresponding <type>xBin</type>. This <type>xBin</type>
      already knows the address of the current free block in the current <type>xPage</type> of its
      free list.
    </para>
    <para>
      Furthermore, in some special cases one even knows the corresponding <type>xBin</type> ( e.g. in
      the case of allocating memory for several monomials in a polynomial ). Then allocating
      memory in xmalloc can be done in very few cpu cycles.
    </para>
  </sect3>
  </sect2>
  <sect2>
    <title>Memory freeing</title>
    <para>
      When freeing memory, located at say <varname>addr</varname>, xmalloc needs to find out on
      which <type>xPage</type> the memory lies.
      This can be done by a bitmask check. After that we can use the special structure of <type>
      xPage</type>s described in Section <link linkend="initxpages" endterm="initxpages.title" />:
    </para>
    <para>
      In function <function>xFreeToPage()</function> in <filename>src/bin.h</filename> the pointer to
      the current free memory block in the page is set via the following instructions:
      <programlisting>
      *(void **)addr = page-&gt;current; // set pointer of next element after addr to page-&gt;current
      page-&gt;current  = addr;</programlisting>
    </para>
    <para>
      So the idea is to use <varname>addr</varname> as new current element in the page. To achieve this we need
      to set the next element in the page, i.e. the old <varname>page->current</varname>, to be the successor of
      addr, i.e. <varname>*(void **)addr</varname>. Afterwards it is left to set <varname>page-&gt;current</varname>
      to <varname>addr</varname>.
    </para>
  </sect2>
  </sect1>
  <sect1>
    <title>
      How to find out if a chunk of memory is allocated to xmalloc or not?
    </title>
    <para>
      At some points during allocations and freeings xmalloc needs to find out
      if a given memory address was allocated by xmalloc or by system malloc.
      xmalloc uses some global data about <type>xRegion</type>s
      in order to make such a check faster.
    </para>
  <sect2>
    <title>Preconditions</title>
    <para>
      Of course, such a check depends on the architecture and system one is
      working on. Let us assume that we work on a 32-bit machine with
      <programlisting>
        sizeof(long)        = 8
        sizeof(system_page) = 4096</programlisting>
      From this we get
      <programlisting>
        sizeof(bit_long)            = 32
        sizeof(log_long)            = 3
        sizeof(log_bit_long)        = 5
        sizeof(log_bit_system_page) = 12</programlisting>
      For xmalloc a memory address reads like described in the following:
      <programlisting>
        |    15 bits    |     5 bits    |   12 bits    |
        ----------------------------------------------------------
        | index of addr | shift of addr | page offset  | page base</programlisting>
    </para>
    <para>
    Thus, in xmalloc we define the size of the index part of a memory
    address via
    <programlisting>
      sizeof(index_part) = (unsigned long) sizeof(system_page) &lt;&lt; sizeof(log_bit_long)</programlisting>
    </para>
    <para>
    With this we are ready to compute of any given memory address its index and its shift:
    <programlisting>
     xGetPageIndexOfAddr(addr) = (unsigned long) sizeof(system_page) &lt;&lt; sizeof(log_bit_long)
     xGetPageShiftOfAddr(addr) = ((unsigned long) addr &amp; sizeof(index_part) - 1) &gt;&gt; sizeof(log_bit_system_page)</programlisting>
    </para>
  </sect2>
  <sect2>
    <title>Registration of xRegions</title>
    <para>
      Having structured the memory addresses it is clear that xmalloc must allocate
      <type>xRegion</type>s, i.e. chunks of continuous system pages in a
      special way. The idea is to register the memory in a special way, more or
      less by keeping track of the boundary, i.e. the lowest and the highest memory
      address of the allocated <type>xRegion</type>. Subdividing memory
      addresses in index and shift parts make inclusion tests way faster than a usual
      check on the complete address.
    </para>
    <para>
      The boundaries of the memory allocated and handled by xmalloc are given by
      <varname>xMinPageIndex</varname> and <varname>xMaxPageIndex</varname>,
      initially defined in <filename>include/globals.h</filename> by
      <programlisting>
        xMinPageIndex = ULLONG_MAX   // max. unsigned long value
        xMinPageIndex = 0</programlisting>
    </para>
    <para>
      Those values are set before even the first <type>xRegion</type> is allocated.
      Once this is done, during its registration the check if the index part of
      the lowest address <varname>startAddr</varname> of the region is greater
      than <varname>xMinPageIndex</varname> fails and xmalloc resets
      <varname>xMinPageIndex</varname> and <varname>xMaxPageIndex</varname>
      correctly. This explains why the initial
      values of those 2 variables are chosen so strangely.
    </para>
    <para>
      By definition we know that every memory address between <varname>startAddr
      </varname> and
      <programlisting>endAddr = startAddr + (numberOfPagesInRegion - 1) * sizeof(system_page)</programlisting>
      is allocated by xmalloc. It is most of the time wrong to assume that any memory address with index between
      <function>xGetPageIndexOfAddr(startAddr)</function> and <function>xGetPageIndexOfAddr(endAddr)</function>
      is allocated by xmalloc, since <varname>startAddr</varname> resp. <varname>endAddr</varname>
      can have bits set resp. not set on positions not in the index part of the memory address.
    </para>
    <para>
      Since <type>xRegion</type>s are aligned by 2^12 bits, the only problems of
      set resp. unset bits can occur in the "shift" section of the memory address.
      When xmalloc registers a new <type>xRegion</type> it keeps track of "correct"
      shifts by storing them in an array called <varname>xPageShifts</varname>:
      For each index of a memory address allocated by xmalloc, <varname>xPageShifts</varname>
      stores the correct shift, it is indexed by <varname>xGetPageIndex(addr)-xMinPageIndex</varname>.
      Clearly, for <function>xGetPageIndexOfAddr(startAddr)</function> as
      well as <function>xGetPageIndexOfAddr(endAddr)</function> these values need to be computed
      correctly, for any index <varname>inbetweenIndex</varname> inbetween we can set all
      bits in the shift part:
      <programlisting>
        xPageShifts[xGetPageIndexOfAddr(startAddr)-xMinPageIndex] |= ~(((unsigned long 1) &lt;&lt; xGetPageShiftOfAddr(startAddr)) - 1)
        xPageShifts[inbetweenIndex-xMinPageIndex]                 |= ULLONG_MAX
        xPageShifts[xGetPageIndexOfAddr(endAddr)-xMinPageIndex]   |= (((unsigned long 1) &lt;&lt; (xGetPageShiftOfAddr(endAddr)+1)) - 1)</programlisting>
    </para>
    <note>
      <para>
        It is important to set the corresponding <varname>xPageShifts</varname> entries by |= instead of =.
        If for the given page index another <type>xRegion</type> was already
        allocated then there are already bits set in the corresponding entry of
        <varname>xPageShifts</varname>. Thus we would corrupt data by overriding
        this values.
      </para>
    </note>
    <para>
    With this information, any memory address between <varname>startAddr</varname>
    and <varname>endAddr</varname> can be detected to be allocated by xmalloc, as
    we see in the following.
    </para>
  </sect2>
  <sect2>
    <title>
      Detecting memory addresses allocated by xmalloc
    </title>
    <para>
      If we have a memory address <varname>addr</varname> of which we would
      like to know if it is allocated by xmalloc we can check this via the
      function <function>xIsPageAddr(addr)</function>. There 3 tests are done:
      <programlisting>
        xGetPageIndexOfAddr(addr) &ge; xMinPageIndex &amp;&amp;
        xGetPageIndexOfAddr(addr) &le; xMaxPageIndex &amp;&amp;
        ((xPageShifts[xGetPageIndexOfAddr(addr) - xMinPageIndex] &amp; ((unsigned long) 1 &lt;&lt; xGetPageShiftOfAddr(addr))) != 0)
      </programlisting>
      The first 2 comparisons check whether the page index of <varname>addr</varname> lies inbetween the
      boundaries of xmalloc's allocated memory chunks. If those hold, then we need to check even more if
      the shift is correct for the given index. This is done by the  3rd comparison.
    </para>
  </sect2>
  <sect2>
    <title>Concluding remarks</title>
    <para>
      xmalloc can decide whether a memory address belongs to it or not quite
      fast using a structured attempt. Subdividing an address in an index
      and a shift part enables xmalloc to track memory addresses without too
      much memory overhead. Note that
      <programlisting>
        sizeof(xPageShifts) &le; 2^15 * sizeof(unsigned long)</programlisting>
      Without using a shift part, this size needs to be ( in the given example )
      32 times greater. This can have a tremendous effect on the memory consumption.
    </para>
  </sect2>
  </sect1>
  <sect1>
    <title>Customized usages of xBins for special purposes</title>
    <para>
      For the following note that xmalloc is a special-purpose memory allocator
      which is a fork of omalloc, the memory allocator of the computer algebra
      system SINGULAR. Thus there are a lot of specializations for handling
      polynomial data, i.e. monomials. Moreover, xmalloc lies an emphasis on
      optimizing so-called Groebner basis computations.
    </para>
  <sect2>
    <title>Special xBins for monomials</title>
    <para>
      Since monomials are the most important data structure for the computer
      algebra system SINGULAR those are handled differently than other data
      types. In order to allocate and free memory for monomials faster
      xmalloc handles them in so-called <emphasis>xSpecBin</emphasis>s.
    </para>
    <para>
      It keeps monomials nearby each other.
    </para>
    <para>
      Size classes do not stop at a given point as it does for usual <type>xBin</type>s.
    </para>
    <para>
      Clearly, other applications using xmalloc may not benefit from this special type resp.
      have advantages using it in other situations. Still the main idea behind it comes from
      omalloc's specialized implementation for SINGULAR, thus we stick with the above explanation
      of its usefulness
    </para>
    <note>
    <para>
      Only for <type>xSpecBin</type>s the size class of the memory blocks stored can exceed
      the constant <varname>__XMALLOC_MAX_SMALL_BLOCK_SIZE</varname>. For memory chunks not
      fitting in the small block size it does not make sense to handle them by xmalloc, in
      general. Monomials are special: They are used a lot of times in SINGULAR and should be
      kept in the <type>xSpecBin</type> structure for a faster freeing.
    </para>
    </note>
  </sect2>
  <sect2>
    <title>The idea behind sticky xBins ( a feature which is still omalloc-only )</title>
    <para>
      There is one special kind of <type>omBin</type>s, so-called <emphasis>
      sticky</emphasis> ones. Those can be used if one knows beforehand that
      lots of same-sized blocks are needed in the following, but which are
      only alive for a small period of time. In this situation omalloc
      allocates a new bin for the needed size-class, although there exists
      already a usual bin. This newly allocated one is denoted <emphasis>
      sticky</emphasis> since it sticks to the <emphasis>real</emphasis>
      bin.
    </para>
    <para>
      There are two main advantages of this attempt:
      <orderedlist>
        <listitem>
          <para>
            All of those temporary objects are packed really tight. Thus a
            good cache locality is achieved, which is of great importance
            for this kind of data.
          </para>
        </listitem>
        <listitem>
          <para>
            The complete sticky bin can be freed once the data in it is not
            used anymore. This means a very fast freeing of the complete
            temporary data at once.
          </para>
        </listitem>
      </orderedlist>
    </para>
    <para>
      Right now, there is one situation in SINGULAR where sticky bins are used:
      In the computation of a Groebner basis SINGULAR internally switches, if
      possible, to some easier temporary rings, e.g. small finite characteristic.
      Doing computations like polynomial reductions in this temporary ring can be
      a lot easier from the computational point of view than the corresponding
      operations in the initial ring. Since the applicability of this method
      depends on the underlying data, SINGULAR cannot use such a temporary ring
      for several elements in a row, but has to recompute the properties resp.
      usefulness each time from scratch. Thus these temporary rings and their
      internal data have to be deleted completely once used.
    </para>
  </sect2>
  </sect1>
  <sect1>
  <title>Guidelines on source code documentation</title>
  <sect2>
  <title>How to document your code</title>
  <para>
  We insist on documenting all files, all functions, all structures and all macros you implement.
  Those documentation must be done in Doxygen style
  ( <ulink url="http://www.stack.nl/~dimitri/doxygen/">http://www.stack.nl/~dimitri/doxygen/</ulink> ).
  For this please retain the given style, for example, that means use <varname>\param</varname>
  instead of <varname>@param</varname> for describing parameters of a functions.
  </para>
  <sect3>
  <title>Files</title>
  <para>
  For files we insist on the at least the following documentation to be given:
  <orderedlist>
  <listitem>
  <para>
    <varname>\file</varname>, the file itself
  </para>
  </listitem>
  <listitem>
  <para>
    <varname>\date</varname>, date of the first implementations
  </para>
  </listitem>
  <listitem>
  <para>
    <varname>\brief</varname>, a short description of the file's functionality
  </para>
  </listitem>
  </orderedlist>
  </para>
  <para>
  This is an example documentation of <filename>src/page.h</filename>:
  <programlisting>
    /**
    * \file   page.h
    * \Author Christian Eder ( ederc\mathematik.uni-kl.de )
    * \date   July 2012
    * \brief  Page handlers for xmalloc.
    *         This file is part of XMALLOC, licensed under the GNU General
    *         Public License version 3. See COPYING for more information.
    * \note   There are some page based functions implemented in the bin.*
    *         files since they depend internally on the strong page &lt;-&gt; bin
    *         connection. Those files are mentioned ( and commented out! )
    *         at the end of this file
    */</programlisting>
  </para>
  <para>
  Moreover, if the file incorporates some oddity, please give a note explaining this
  behaviour via <varname>\note</varname>.
  </para>
  </sect3>
  <sect3>
  <title>Functions</title>
  <para>
  For functions we insist on the at least the following documentation to be given:
  <orderedlist>
  <listitem>
  <para>
    <varname>\fn</varname>, the function itself
  </para>
  </listitem>
  <listitem>
  <para>
    <varname>\brief</varname>, a brief description of what the function is doing
  </para>
  </listitem>
  <listitem>
  <para>
    <varname>\param</varname>, a description of each parameter used
  </para>
  </listitem>
  <listitem>
  <para>
    <varname>\return</varname>, the return value of the function
  </para>
  </listitem>
  </orderedlist>
  </para>
  <para>
  This is an example documentation of <function>xIsAddrOnPage</function> in <filename>src/page.h</filename>:
  <programlisting>
   /**
    * \fn static inline BOOLEAN xIsAddrOnPage(void *addr, xPage page)
    *
    * \brief Checks if \c addr is on \c page .
    *
    * \param addr memory address to be checked
    *
    * \param page \c xPage to be checked
    *
    * \return true if \c addr is on \c page , false else
    */</programlisting>
  </para>
  <para>
  Moreover, if your function incorporates some oddity, please give a note explaining this
  behaviour via <varname>\note</varname>.
  </para>
  </sect3>
  <sect3>
  <title>Structures</title>
  <para>
  For structures we insist on the at least the following documentation to be given:
  <orderedlist>
  <listitem>
  <para>
    <varname>\struct</varname>, the structure itself
  </para>
  </listitem>
  <listitem>
  <para>
    <varname>\brief</varname>, a brief description of what the structure is doing
  </para>
  </listitem>
  </orderedlist>
  </para>
  <para>
  Moreover, you must document all elements the struct consists of in place.
  </para>
  <para>
  This is an example defintion and documentation of <varname>xPageStruct</varname>
  in <filename>src/data.h</filename>:
  <programlisting>
    /**
    * \struct xPageStruct
    *
    * \brief Structure of the internal xmalloc page including a header for better
    * handling in the allocator.
    */
    struct xPageStruct {
      long     numberUsedBlocks; /**&lt; number of used blocks in this page */
      void*    current;          /**&lt; pointer to free list this page is in */
      xPage    prev;             /**&lt; previous page in the free list */
      xPage    next;             /**&lt; next page in the free list */
      void*    bin;              /**&lt; bin of this page */
      xRegion  region;           /**&lt; region this page comes from */
    };</programlisting>
  </para>
  <para>
  Moreover, if your function incorporates some oddity, please give a note explaining this
  behaviour via <varname>\note</varname>.
  </para>
  </sect3>
  <sect3>
  <title>Macros</title>
  <para>
  If you really need to define new macros the documentation is rather short:
  <orderedlist>
  <listitem>
  <para>
    <varname>\brief</varname>, a brief description of what the macro is doing
  </para>
  </listitem>
  </orderedlist>
  </para>
  <para>
  In the settings of xmalloc's <filename>Doxyfile</filename> all macros are extended and
  extracted. There are other solutions for documenting macros, for the sake of
  simplicity we stick to this variant.
  </para>
  <para>
  This is an example documentation of <varname>xAssert</varname>
  in <filename>src/xassert.h</filename>:
  <programlisting>
    /**
    * \brief xmalloc-specific assert
    */</programlisting>
  </para>
  <para>
  Moreover, if your function incorporates some oddity, please give a note explaining this
  behaviour via <varname>\note</varname>.
  </para>
  </sect3>
  </sect2>
  <sect2>
    <title>How to document ongoing implementational tasks</title>
    <sect3>
      <title>Functionality to be implemented</title>
      <para>
        Implementations that need to be migrated from omalloc, but haven't been
        until now. They are already used in the current code of xmalloc, mostly the
        line the function appears for the first time is the one highlighted with a trailed
        <varname>TOODOO</varname> comment. For example,
        <programlisting>
        int k = functionStillToBeImplementedInXmalloc(para1, para2); // TOODOO</programlisting>
      </para>
    </sect3>
    <sect3>
      <title>Functionality from omalloc possibly not used in xmalloc</title>
      <para>
        There is functionality in omalloc that will possibly not be part of xmalloc.
        For a lot of such stuff we need to discuss and think about if we keep them,
        modify them or remove them completely. Clearly, in the process of creating
        xmalloc we copy functions from omalloc at some point that include such
        functionality. This functionality should be commented out in the following
        way:
        <programlisting>
        // OMALLOC FUNCTIONALITY MISSING
        // functionalityStillMissing = 2;</programlisting>
      </para>
    </sect3>
  </sect2>
  </sect1>
  <sect1>
  <title>Agreements on the xmalloc test suite</title>
  <sect2>
  <title>Testing frameworks</title>
  <para>
  Keeping dependencies of xmalloc at a low we decided to not use any third-party
  testing framework like <emphasis>check</emphasis> or <emphasis>dejagnu</emphasis>.
  </para>
  <para>
  Still we try to keep our test suite up to date. For this we encourage developers
  to include a test for any new functionality in xmalloc. The test suite is dedicated
  to be structured into subdirectories which keep specialized tests:
  <programlisting>
                           tests/
                          /    \
                         /      \
                        /        \
                      unit/     basic/</programlisting>
  In <filename>unit/</filename> we keep all unit tests. <filename>basic/</filename> is the
  place where to put bigger and more general tests that do not only test some special unit,
  but are still basic.
  </para>
  <para>
  There are 3 shell sripts in the
  <filename>tests/</filename> directory with which one can run either the tests in the above
  mentioned subdirectories separately or all tests at once:
  <programlisting>
  ./run-unit-tests.sh
  ./run-basic-tests.sh
  ./run-all-tests.sh</programlisting>
  </para>
  <note>
  <para>
  For those shell scripts to work correctly please note that there is a naming
  convention for all tests in any of the above mentioned subdirectories.
  The name of each test file must meet the following template:<filename>test-*.c</filename>.
  For example, in <filename>unit/</filename> a unit test for checking reallocations with
  small memory block sizes should be named <filename>test-realloc-small-blocks.c</filename>.
  </para>
  </note>
  </sect2>
  <sect2>
  <title>Using assert() in the test suite</title>
  <para>
  Again we do not want xmalloc to imply too many dependencies. Thus we stick to the
  default <function>assert()</function>. For a more accurate printout once an assert
  fails we have overriden it. The default assert functionality to be used in xmalloc
  is called by
  <programlisting>
  __XMALLOC_ASSERT(expression);</programlisting>
  This returns not only where the assumption that <varname>expression</varname> is
  correct failed, but also expression as a string itself. This makes debugging a lot
  easier.
  </para>
  </sect2>
  </sect1>
  <appendix>
    <title>Thread-safe memory management in general</title>
    <para>
      Next we give a short overview of current ideas and trends in multi-threaded
      memory management. Hereby we concentrate on 3 of the most famous allocators
      ( ordered by their first public release dates ):
      <orderedlist>
      <listitem>
        <para>
          Hoard by Emery Berger ( <ulink url="http://www.hoard.org/">http://www.hoard.org/</ulink> )
        </para>
      </listitem>
      <listitem>
        <para>
          Jemalloc by Jason Evans ( <ulink url="http://www.canonware.com/jemalloc/">http://www.canonware.com/jemalloc/</ulink> )
        </para>
      </listitem>
      <listitem>
        <para>
          TCmalloc by people from Google ( <ulink url="http://gperftools.googlecode.com/">http://gperftools.googlecode.com/</ulink> )
        </para>
      </listitem>
      </orderedlist>
    </para>
    <para>
      Reviewing the common approaches to receive a fast, scalable and
      thread-safe allocator we also give a discussion on efficiency
      boundaries inherited by multi-threaded allocations.
    </para>
    <sect1>
      <title>Problems occurring when using multiple threads concurrently</title>
      <para>
        Using multiple threads for allocation disadvantages can occur that are not
        possible in a single-threaded environment. Moreover, well-known problems
        get way worse.
      </para>
    <sect2>
      <title>False sharing</title>
      <para>
        False sharing is a problem that does not occur in single-threaded allocators,
        but is inherited from optimization ideas plainly based on locality of space:
        Since packing data as much as possible, e.g. padding memory chunks, one wants
        to achieve a good locality of reference. This means that data used nearby in
        time should be stored in nearby memory locations.
      </para>
      <para>
        For a multi-threaded allocator this concept gets way more complex: Let us
        assume that the allocator divides a cache line into 8 byte chunks. If
        multiple threads request objects of size 8 bytes, then the allocator may
        give each of these threads a piece of the cache line.
      </para>
      <para>
        Clearly, such a behaviour, often called <emphasis>actively induced false
        sharing</emphasis> leads to very bad performance. Concurrently working
        threads try to lock the cache line, thus the other threads have to wait
        to set the lock themselves.
      </para>
      <para>
        Moreover, induced by this, also a <emphasis>passively induced false
        sharing</emphasis> is possible: Assume that after freeing the above
        mentioned chunks of memory the allocator allows each processor to reuse
        the memory pieces it freed. With this, false sharing can get even worse.
      </para>
    </sect2>
    <sect2>
      <title>Blowing up the memory usage</title>
       <para>
         The blowing up of memory consumed by the allocator can be illustrated by a
         very easy example: Assume an application which uses 2 threads. A producer
         thread allocates a block of memory and hands it to the consumer thread which
        further processes it and frees it later on. If the used memory is not
        available to the producer thread after its freeing a blow up in memory
        emerges.
       </para>
       <para>
        Moreover, keep in mind that there is a trivial blow up occurring: Thinking
        about an application in which all threads have to allocate and free memory
        of a given size <varname>s</varname> the application ideally needs only a
        chunk of memory of size <varname>s</varname> in total. If the different steps
        resp. threads of this application can work in parallel we need at least
        a block of memory of the size <varname>n*s</varname> where <varname>n
        </varname> is the maximum of the number of threads working in parallel.
       </para>
    </sect2>
    </sect1>
    <sect1>
       <title>How to efficiently allocate memory in a multi-threaded enivornment</title>
       <para>
        In order to reduce the probability of concurrently executing threads using
       the same cache line, the most common solution is to use multiple regions,
       areas, heaps, caches or whatever you want to call it ( we stick with
       <emphasis>heap</emphasis> in the following ). Let us assume in the
       following a system with <varname>n</varname> processors resp. cores. For the
       above mentioned allocators it is common to use a multiple of <varname>n
       </varname> local heaps. By some hashing technique a current thread is
       related to exactly 1 local heap.
       </para>
       <para>
       Any local heap owns bigger blocks of memory resp. consists of corresponding
       free lists. Besides the local heaps there exists 1 global heap. It also has
       some memory chunks preallocated.
       </para>
       <para>
       The main allocation procedure is the following:
       <orderedlist>
       <listitem>
       <para>
        The thread which needs memory searches it local heap. If there is a free
       chunk of memory of the required size class, the allocation is done.
       </para>
       </listitem>
       <listitem>
       <para>
       If the local heap does not have any appropriate free memory block left,
       the thread has to ask the global heap for memory. If this leads to a
       positive response, the thread acquire the given memory to its local heap.
       </para>
       </listitem>
       <listitem>
       <para>
       If the global heap also has no appropriate chunk of memory left for the
       enquiry of the thread, then the global heap allocates a big bunch of
       memory from the system.
       </para>
       </listitem>
       </orderedlist>
      </para>
      <para>
       Using a scheme like this the probability of false sharing can be decreased
       quite a lot. On the other hand, a new problem appears: Once memory is freed
       one needs to take care of the load balance. Once there are 3 local heaps with
       plenty of available memory on 1 thread completely full making enquiries to
       the global heap something has went wrong for sure.
       </para>
    </sect1>
    <sect1>
      <title>Distributing freed memory</title>
       <para>
       Using the local heap approach the question of how to distribute beforehand
       used and now freed memory chunks becomes an important question. Clearly, the
       memory freed by a thread should be kept to the local heap it came from and
       should not be handled back to the system. This increases reusability and
       improves the efficiency of the allocator.
       </para>
       <para>
       On the other hand, there must be some threshold at which big chunks of free
       memory in a local heap is handed back to the global heap in order make it
       usable also for the other threads. Otherwise an equilibrium in supply and
       demand cannot be achieved at all.
       </para>
       <para>
       Also for this there does not exist the one best strategy in every possible
       situation. Handling the distribution of already owned memory efficiently
       is one of the main tasks a fast thread-safe memory allocator has to deal
       with.
       </para>
    </sect1>
  </appendix>
  <appendix>
    <title>What are possible ideas for making xmalloc thread-safe?</title>
    <para>
      We could try a thread-caching attempt like tcmalloc and jemalloc are using.
      For this we need to discuss at which level the <emphasis>locality</emphasis>
      starts: Should there be local <type>xRegion</type>s, or only local <type>
      xBin</type>s with completely global <type>xRegion</type>s?
    </para>
  <sect1>
    <title>Keeping <type>xRegion</type>s global</title>
    <para>
      If we let <type>xRegion</type>s global this means that we need to set a lock
      whenever we need a new page from the region. This could hinder other threads
      on going on for a high percentage of the overall computation.
    </para>
    <para>
      On the other hand, this attempt would keep the complexity of implementing
      xmalloc a lot easier. Working with global regions for allocating new
      pages makes xmalloc way more static for every bigger memory allocation.
      Having the problem of being not dynamically enough for many-threaded
      applications this attempt leaves out the problem of implementing a good
      scheduler for handling and balancing big local memory chunks. Clearly,
      the bigger the memory chunks handled locally, the more careful they need
      to be handled. Having 200 MB of free memory on thread A, but no free
      memory for thread B something went wrong for sure.
    </para>
  </sect1>
  <sect1>
    <title>Making <type>xRegion</type>s local</title>
    <para>
      If every thread has its own region allocating new pages from them is a
      completely lock-free process. Clearly, there has to be the concept of a
      global <emphasis>super-xRegion</emphasis>. This region would be empty
      in the beginning, but gets free pages from the different threads back
      once a given threshold is exceeded. Besides the above mentioned advantage,
      this attempt introduces some problems xmalloc needs to take care of:
      <orderedlist>
      <listitem>
        <para>
          Checking if a memory address is allocated by xmalloc or not is a
          <emphasis>global</emphasis> action. Since the regions are local
          we need to check in each thread, if the corresponding memory address
          is allocated or not. On the other hand, all this checks are completely
          independent of each other, thus it is possible do perform this check
          in parallel. This should still be faster than doing it by 1 thread
          only in the situation of a global region.
        </para>
      </listitem>
      <listitem>
        <para>
          Once in a while, every thread needs to look check at how big its own
          region has become. If a given threshold is exceeded a fixed number of
          free pages should be moved to the global super-xRegion. This helps
          balancing the memory. Once there are pages available in the super-
          xRegion, a thread in the need of a new free page would not call system
          malloc to get a bunch of new pages for its local <type>xRegion</type>,
          but would try to receive it from the super-xRegion. Clearly this is a
          process where all other threads are locked. On the other hand, if a
          thread asks system malloc for a new bunch of free pages this is also
          a locked process, isn't it?
        </para>
      </listitem>
      </orderedlist>
    </para>
  </sect1>
  </appendix>
  <appendix>
  <title>Some notes on jemalloc's internal structures</title>
  <para>
    In this appendix we give a short summary of jemalloc's internal structures.
    This covers a description of jemalloc's usual malloc() process as well as how
    the configuration of the thread-safe framework is handled.
  </para>
  <sect1>
  <title>A basic memory allocation in jemalloc</title>
  <para>
    The malloc-compatible implementations of <function>malloc()</function>,
    <function>realloc()</function>, <function>calloc()</function>, and
    <function>valloc()</function> can be found in <filename>src/jemalloc.c</filename>.
    All corresponding <function>je_*</function> functions check if the function
    <function>malloc_init()</function> was already called.
  </para>
  <note>
  <para>
    The configuration setup explained in Section <link linkend="jemallocconf" endterm="jemallocconf.title" />
    The corresponding functions are called only once. When it is set, it won't be
    called again in upcoming allocation steps.
  </para>
  </note>
  <sect2 id="jemallocconf">
  <title id="jemallocconf.title">Setting configuration variables in jemalloc</title>
  <para>
    <function>malloc_init()</function> checks if the global variable
    <varname>malloc_initialized</varname> is set to be true. Only if this is not the case,
    it calls the function <function>malloc_init_hard()</function>.
  </para>
  <para>
    <function>malloc_init_hard()</function> sets the following stuff ( in the presented
    order ):
    <orderedlist>
    <listitem>
    <para>
      Initialization of an array of arenas of length 1
    </para>
    </listitem>
    <listitem>
    <para>
      Taking the lock
    </para>
    </listitem>
    <listitem>
    <para>
      Calling <function>malloc_conf_init()</function>
    </para>
    </listitem>
    <listitem>
    <para>
      Registering fork handlers with pthreads
    </para>
    </listitem>
    <listitem>
    <para>
      Checking different other settings w.r.t. multi-threading
    </para>
    </listitem>
    <listitem>
    <para>
      Getting number of cpus
    </para>
    </listitem>
    <listitem>
    <para>
      Allocating number of arenas corresponding to number of cpus
    </para>
    </listitem>
    </orderedlist>
  </para>
  </sect2>
  <sect2>
  <title>Processing the allocation step</title>
  <para>
    The real allocation process in jemalloc takes place in <function>imalloc()</function>
    which is defined in <filename>jemalloc_internal.h</filename>. Depending on a first
    size threshold denoted <varname>arena_maxclass</varname> it splits up into
    <orderedlist>
    <listitem>
    <para>
      <function>arena_malloc()</function>
    </para>
    </listitem>
    <listitem>
    <para>
      <function>huge_malloc()</function>
    </para>
    </listitem>
    </orderedlist>
  </para>
  <sect3>
  <title>How <function>arena_malloc()</function> handles allocations</title>
  <para>
    In <function>arena_malloc()</function> another size check takes place with a macro
    called <varname>SMALL_MAXCLASS</varname>. This is combined with a check of the return
    value of <function>tcache_get(true)</function>. The following table shows what function
    is called in which situation:
  </para>
  <para>
  <table frame="all">
  <title>Calling conventions in <function>arena_malloc()</function> in jemalloc</title>
  <tgroup cols="3" align="center" colsep="1">
    <thead>
    <row >
      <entry><?dbhml entry-bgcolor="#000000" ?>Function name</entry>
      <entry><function>tcache_get(true)</function></entry>
      <entry><function>var &le; SMALL_MAXCLASS</function></entry>
    </row>
    </thead>
    <tbody>
    <row>
      <entry><function>tcache_alloc_small</function></entry>
      <entry><envar>NULL</envar></entry>
      <entry><envar>TRUE</envar></entry>
    </row>
    <row>
      <entry><function>tcache_alloc_large</function></entry>
      <entry><envar>NULL</envar></entry>
      <entry><envar>FALSE</envar></entry>
    </row>
    <row>
      <entry><function>arena_alloc_small</function></entry>
      <entry><envar>!NULL</envar></entry>
      <entry><envar>TRUE</envar></entry>
    </row>
    <row>
      <entry><function>arena_alloc_large</function></entry>
      <entry><envar>!NULL</envar></entry>
      <entry><envar>FALSE</envar></entry>
    </row>
    </tbody>
  </tgroup>
  </table>
  </para>
  <sect4>
  <title>Usage of <function>tcache_get(bool create)</function></title>
  <para>
    In order to understand the above ramification in <function>arena_malloc()</function>
    what the purpose of function <function>tcache_get(true)</function> is.
  </para>
  </sect4>
  </sect3>
  </sect2>
  </sect1>
  </appendix>
</article>
